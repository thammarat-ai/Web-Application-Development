# สถาปัตยกรรมแบบไม่บล็อก (Nonblocking Architectures)

อีกข้อได้เปรียบสำคัญที่ Node มอบให้ อาจน่าสนใจสำหรับบุคลากรด้าน SysOps และ DevOps มากกว่า&#x20;

Node ใช้สถาปัตยกรรมแบบไม่บล็อก อะซิงโครนัส และเธรดเดียว นี่หมายความว่าอย่างไร?&#x20;

Apache รันแอปพลิเคชันเช่น PHP โดยใช้โมเดลแบบมัลติโปรเซสหรือมัลติเธรด นั่นคือ คำขอต่างๆ (แม้แต่สำหรับหน้าเดียวกัน) จะถูกดำเนินการแยกจากกันในเธรดหรือโปรเซสของระบบปฏิบัติการที่แยกกัน&#x20;

ข้อดีของวิธีนี้คือปัญหาในการทำงานของเธรด/โปรเซสหนึ่งจะไม่ส่งผลกระทบต่อเธรดอื่นๆ&#x20;

ข้อเสียคือมีจำนวนโปรเซสที่ใช้ได้จำกัด (โดยทั่วไปอยู่ในช่วง 150-250) และมีจำนวนเธรดทั้งหมดที่ใช้ได้จำกัด (โดยทั่วไปอยู่ในช่วง 25-50 ต่อโปรเซส) หากไม่มีเธรดว่าง คำขอจะต้องรอ&#x20;

นอกจากนี้ แม้ว่า Linux จะมีประสิทธิภาพมากในการสลับระหว่างโปรเซส/เธรด (เรียกว่าการสลับบริบท หรือ context switching) แต่ก็ยังมีต้นทุนด้านเวลา (ประมาณ 65 ไมโครวินาที) ในการสลับบริบททุกครั้ง แม้ว่าจะดูเหมือนไม่ใช่ต้นทุนด้านเวลามากนัก แต่เมื่อมีการเชื่อมต่อหรือคำขอพร้อมกันประมาณ 4000 รายการ ทำให้ CPU ของเซิร์ฟเวอร์จะใช้เวลาส่วนใหญ่ในการสลับระหว่างโปรเซสมากกว่าการดำเนินการโปรเซสจริงๆ นี่เป็นหนึ่งในเหตุผลที่ทำไมเว็บไซต์ที่มีผู้ใช้งานมากจึงต้องใช้ฟาร์มเซิร์ฟเวอร์

Node ในทางตรงกันข้าม ใช้เพียงเธรดเดียว นั่นหมายความว่าไม่ต้องสูญเสียเวลาไปกับการสลับบริบทระหว่างเธรด ซึ่งเป็นประโยชน์อย่างมากสำหรับเว็บไซต์ที่มีการใช้งานสูง

แต่คุณอาจสงสัยว่า เธรดเดียวจะสามารถจัดการกับคำขอพร้อมกันจำนวนมากได้อย่างไร?&#x20;

กุญแจสำคัญที่ทำให้ Node มีประสิทธิภาพ คือการใช้สถาปัตยกรรมแบบไม่บล็อกและอะซิงโครนัส ดังรูปที่ 2

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption><p>รูปที่ 2 สถาปัตยกรรมแบบ blocking thread</p></figcaption></figure>

แสดงให้เห็นถึงวิธีการแบบบล็อกทั่วไป (เช่น PHP) โดยใช้การเปรียบเทียบกับชีวิตจริง&#x20;

ในขณะที่รูปที่ 3 แสดงให้เห็นถึงวิธีการแบบไม่บล็อกที่ใช้โดย Node



<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption><p>รูปที่ 2 สถาปัตยกรรมแบบ nonblocking thread</p></figcaption></figure>

การเปรียบเทียบกับร้านอาหารไม่ได้เป็นเรื่องเพ้อฝันอย่างที่อาจดูเหมือน มันจะเป็นร้านอาหารที่ไม่มีประสิทธิภาพอย่างแน่นอนหากมอบหมายให้คนเพียงคนเดียวจัดการกับทุกงานที่จำเป็นสำหรับแต่ละโต๊ะ หลังจากรับออเดอร์ (เทียบได้กับการรับคำขอ HTTP) เราคงไม่ต้องการให้พนักงานเสิร์ฟเดินไปที่บาร์ ผสมเครื่องดื่ม จากนั้นเดินไปที่ครัว และเริ่มทำอาหารตามออเดอร์ ดังที่เห็นในข้อ 3 ในรูปที่ 2 เธรดสามารถถูกบล็อกในขณะที่รอให้งานอื่นเสร็จสิ้น (เช่น การดึงข้อมูลจากฐานข้อมูล)

ในตัวอย่างร้านอาหารของเรา ลองจินตนาการถึงลูกค้าที่น่าสงสารที่กำลังสงสัยอย่างหงุดหงิดว่าอาหารของพวกเขาอยู่ที่ไหน ในขณะที่พนักงานเสิร์ฟ/บาร์เทนเดอร์/พ่อครัวกำลังรอให้คนอื่นไปซื้อของชำเพื่อหาส่วนผสมที่จำเป็นสำหรับออเดอร์นั้นให้เสร็จ!

สถานการณ์นี้มีลักษณะอย่างไรในโค้ดโปรแกรม? ใน PHP คุณอาจเขียนโค้ดที่มีลักษณะดังนี้:

```php
if ( $result = $db->fetchFromDataBase($sql) ) {
    // ทำอะไรบางอย่างกับผลลัพธ์
    . . .
}
if ( $data = $service->retrieveFromService($url, $querystring) ) {
    // ทำอะไรบางอย่างกับข้อมูล
    . . .
}
// ไม่จำเป็นต้องใช้ $result หรือ $data
doSomethingElseReallyImportant();
```

ในตัวอย่างนี้ การเรียก fetch และ retrieve ภายในเงื่อนไขทั้งสองเป็นการเรียกแบบบล็อก ซึ่งหมายความว่าการทำงานในเธรดจะหยุดจนกว่าเมธอดจะส่งคืนผลลัพธ์ ฟังก์ชัน doSomethingElseReallyImportant() ไม่สามารถทำงานได้จนกว่าสองฟังก์ชันก่อนหน้านี้จะทำงานเสร็จ

ใน JavaScript เราสามารถเขียนโค้ดเดียวกันนี้ในลักษณะที่ไม่บล็อกได้:

```javascript
fetchFromDataBase(sql, function(results) {
    // ทำอะไรบางอย่างกับผลลัพธ์
    . . .
});
retrieveFromService(url, querystring, function(data) {
    // ทำอะไรบางอย่างกับข้อมูล
    . . .
});
// ส่วนนี้ไม่ถูกบล็อกโดยสองบรรทัดก่อนหน้า
doSomethingElseReallyImportant();
```

ในกรณีนี้ไม่มีการบล็อกและฟังก์ชัน doSomethingElseReallyImportant() ไม่ถูกหน่วงเวลา JavaScript จึงเป็นภาษาที่เหมาะสมที่สุดสำหรับสถาปัตยกรรมแบบอะซิงโครนัสนี้ เนื่องจากงานส่วนใหญ่ที่คุณทำกับภาษานี้เกี่ยวข้องกับการส่งฟังก์ชันคอลแบ็คไปยังงานหรือตัวแทนที่จะใช้คอลแบ็คในอนาคต

เนื่องจาก Node หลีกเลี่ยงต้นทุนด้านเวลาที่สำคัญที่เกิดจากการบล็อกและการสลับบริบท จึงสามารถจัดการกับคำขอพร้อมกันได้จำนวนมากอย่างน่าทึ่ง (สูงถึง 100,000) เมื่อ Walmart เปลี่ยนไปใช้ Node.js ในวัน Black Friday (วันที่มีโหลดคำขอสูงสุด) ในปี 2014 การใช้งาน CPU ของเซิร์ฟเวอร์ไม่เคยเกิน 2% แม้จะมีผู้ใช้หลายล้านคน แน่นอนว่าข้อเสียที่สำคัญของวิธีนี้คือการเกิดข้อผิดพลาดขณะให้บริการคำขอหนึ่งจะส่งผลกระทบต่อทุกคำขอ

